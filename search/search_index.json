{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hyper Protect Virtual Server Wildfire Workshop \u00b6 Welcome to our Hyper Protect Virtual Server workshop. Hyper Protect Virtual Server is IBM\u2019s open application environment that is uniquely engineered for trusted computing. This workshop provides a primer on Hyper Protect Virtual Server and practical use cases relevant to the enterprise. In addition, you will gain hands-on experience with IBM\u2019s unique secure image build process to build a secure image and deploy it inside a FIPS 197-compliant protected memory enclave. Next, you will learn about Hyper Protect Virtual Server\u2019s crypto service built on a FIPS 140-2 Level 4-compliant HSM. Lastly, you will gain hands-on experience exploiting the crypto service. Agenda \u00b6 Introduction to Hyper Protect Virtual Server Hyper Protect Use Cases & Demo Introduction to the Secure Image Build Process Lab: Build and Deploy Your First Hyper Protect Virtual Server Image Introduction to HSM-backed Crypto Service Lab: Crypto Service Exploitation Next Steps on Your Journey & Wrap Up Acknowledgements \u00b6 Thanks to the following contributors: Workshop owners \u00b6 Barry Silliman Garrett Woodworth Jin VanStee","title":"Home"},{"location":"#hyper-protect-virtual-server-wildfire-workshop","text":"Welcome to our Hyper Protect Virtual Server workshop. Hyper Protect Virtual Server is IBM\u2019s open application environment that is uniquely engineered for trusted computing. This workshop provides a primer on Hyper Protect Virtual Server and practical use cases relevant to the enterprise. In addition, you will gain hands-on experience with IBM\u2019s unique secure image build process to build a secure image and deploy it inside a FIPS 197-compliant protected memory enclave. Next, you will learn about Hyper Protect Virtual Server\u2019s crypto service built on a FIPS 140-2 Level 4-compliant HSM. Lastly, you will gain hands-on experience exploiting the crypto service.","title":"Hyper Protect Virtual Server Wildfire Workshop"},{"location":"#agenda","text":"Introduction to Hyper Protect Virtual Server Hyper Protect Use Cases & Demo Introduction to the Secure Image Build Process Lab: Build and Deploy Your First Hyper Protect Virtual Server Image Introduction to HSM-backed Crypto Service Lab: Crypto Service Exploitation Next Steps on Your Journey & Wrap Up","title":"Agenda"},{"location":"#acknowledgements","text":"Thanks to the following contributors:","title":"Acknowledgements"},{"location":"#workshop-owners","text":"Barry Silliman Garrett Woodworth Jin VanStee","title":"Workshop owners"},{"location":"glossary/","text":"This glossary of terms consolidates the terms for the Hyper Protect Virtual Server offering in alphabetical order to help both customers and internal team members to understand our offering better. Appliance \u00b6 IBM Secure Service Container based appliance provided by an Appliance Vendor. From Hosting Appliance perspective, it is the combination of IBM Secure Service Container and the Hyper Protect Virtual Server Hosting Appliance. Appliance Administrator \u00b6 The person administrating an appliance which includes tasks, such as configuring storage, or memory to the appliance or performing other configuration tasks through the API provided by SSC/the Hosting Appliance. Appliance Operational Data \u00b6 Metrics, logs, appliance dump data, error logs, stack traces, kernel dump, etc. Appliance Protected Data \u00b6 Appliance secrets, workload data, configuration data, settings, and other internal information stored by an appliance. Appliance Vendor \u00b6 An internal, or external exploiter of SSC, packaging SSC into an appliance. BYOK \u00b6 The abbreviation of Bring Your Own Key, which allows you to import your existing keys to Hyper Protect Crypto Services service instances that protect your keys with advanced encryption. BYOI \u00b6 The abbreviation of Bring Your Own Image, which is a part of IBM Hyper Protect Virtual Server solution to support the development and deployment of your own container images on top of the Secure Service Container framework. Container \u00b6 A runtime instance of an Open Container Image (OCI) image. Crypto administrator \u00b6 The person who signs commands that are issued to the crypto units. Multiple administrators can be added to one crypto unit to increase security. Crypto units \u00b6 A single unit that represents a hardware security module and the corresponding software stack that is dedicated to the hardware security module for cryptography. Data encryption keys \u00b6 A cryptographic key used to encrypt data that is stored in an application. Datapool \u00b6 Synonyms for Storage Pool. Docker Content Trust \u00b6 Docker Content Trust (DCT) is a feature in the Docker containerization platform that provides the ability to use digital signatures for data sent to and received from remote Docker registries. These signatures allow client-side or runtime verification of the integrity and publisher of specific image tags. Through DCT, image publishers can sign their images and image consumers can ensure that the images they pull are signed. Publishers could be individuals or organizations manually signing their content or automated software supply chains signing content as part of their release process. Docker registry \u00b6 A Docker registry is a storage and content delivery system, holding named Docker images, available in different tagged versions. EP11 \u00b6 The abbreviation of Enterprise PKCS #11, which is specifically designed for customers seeking support for open standards and enhanced security. The EP11 library provides an interface very similar to the industry-standard PKCS #11 API. Envelope encryption \u00b6 The process of encrypting data with a data encryption key and then encrypting the key with a root key that can be fully managed. FIPS 140-2 compliance \u00b6 An organization\u2019s adherence to the Federal Information Processing Standards (FIPS) 140-2 standards. This standard specifies the security requirements that will be satisfied by a cryptographic module utilized within a security system protecting sensitive information. FIPS 140-2 outlines four levels of security: Level 1 - the lowest level of security. It covers the basic security features in a cryptographic module. Level 2 - improves the physical security aspects of cryptographic modules. Examples of required physical security measures are tamper-evident coatings, seals, or pick-resistant locks. Role-based authentication is included in this security level and ensures the operator accessing the module is authorized and is limited to their assigned actions. Level 3 - requires enhanced physical security, potentially with products available from the private sector. A multi-chip embedded module has to be contained in a strong enclosure that zeroizes critical security parameters when it is removed. This security level also uses identity-based authentication. Level 4 - requires tamper detection circuits to be able to detect any device penetration. This level is best for when cryptographic modules are in a physically unprotected environment that intruders can access. Modules must be able to detect fluctuations and zeroize themselves. Level 4 also protects against security compromises due to environmental conditions. FIPS 197 compliance \u00b6 An organization\u2019s adherence to Federal Information Processing Standards (FIPS) 197 which is an algorithmic standard that addresses the Advanced Encryption Standard (AES). AES specifies a FIPS-approved cryptographic algorithm that can be used to protect electronic data. The AES algorithm is a symmetric block cipher that can encrypt and decrypt information. GPG \u00b6 The abbreviation of Gnu Privacy Guard, which is an open standard used for signing, encrypting, and decrypting texts with public and private keys to increase the security of communications. GREP11 \u00b6 Represents Enterprise PKCS #11 (EP11) APIs over gRPC calls, which is designed to be a stateless interface for cryptographic operations on cloud. gRPC \u00b6 A modern open source high performance remote procedure call (RPC) framework that can connect services in and across data centers for load balancing, tracing, health checking, and authentication. Hardware security module \u00b6 A physical appliance that provides on-demand encryption, key management, and key storage as a managed service. Hosting Appliance \u00b6 A technical component within IBM Secure Service Container based appliances, providing the enablement for running Docker-based workloads. Image \u00b6 The basis of the containers. An image is an ordered collection of root file system changes and the corresponding execution parameters for use within a container runtime. ISV \u00b6 The abbreviation of Independent Software Vendor, who provides software solutions by developing and deploying containerized applications to the Secure Service Container partitions. Master key \u00b6 An encryption key that is used to protect a crypto unit. The master key provides full control of the hardware security module and ownership of the root of trust that encrypts the chain keys, including the root key and standard key. Management Utilities \u00b6 A set of applications to provide an alternate way of configuring Hyper Protect Crypto Services service instances using signature keys and master key parts stored on smart cards. Management server \u00b6 An x86 or s390x Linux management server used to run the commands provided by the Hyper Protect Virtual Servers offering, and administer the offering. Manifest \u00b6 A manifest is generated by the Secure Build for audit purpose, which contains a copy of the github project cloned by the Secure Build container, a copy of the build log, and a build.json with the build status. Manifest public key \u00b6 A manifest public key is used to verify the manifest generated by the Secure Build. Manifest private key \u00b6 A manifest private key is used to sign the manifest during the Secure Build. Mutual TLS \u00b6 Mutual authentication or two-way authentication refers to two parties authenticating each other at the same time. Mutual TLS is doing this over the TLS protocol. Namespace \u00b6 A namespace such as ibmzcontainers that contains a number of unique images. For examples, the images include hpvsop-base, hyperpcons-worker, hyperpcons-riaas, and so on. Partition \u00b6 A partition is the logic partition (LPAR) on the mainframe, and can be created by using the logic partitioning tools such as Hardware Management Console (HMC) or other logical partitioning tools. PKCS #11 \u00b6 The abbreviation of Public-Key Cryptography Standards #11, which defines a platform-independent API to cryptographic tokens, such as HSM and smart cards. Protected memory enclave \u00b6 Defined private regions of memory whose contents are protected and unable to be read or saved to any process outside the enclave itself. Quotagroup \u00b6 The storage assigned to a workload running on an appliance. The appliance administrator assigns FCP, or ECKD based storage to an appliance. He then creates quotagroups, representing parts of the underlying storage. He finally assigns quotagroups to workloads through the appliance API. Root keys \u00b6 A symmetric wrapping key that is used for encrypting and decrypting other keys that are stored in a data service. Registry \u00b6 A Registry is a hosted service containing repositories of container images that responds to the Registry API. For example, Docker Hub. Repository \u00b6 A repository is a set of containerized images. A repository can be shared by pushing it to a registry server. Different images in the repository can be labeled using tags. For example, hpvsop-base. Repository definition files \u00b6 An encrypted registration file or a repository definition file is used to register the repository, for authentication or validation reasons, such that a Hosting Appliance will trust that the image, when pulled from the registry, is authentic. Repository registration files \u00b6 A cleartext Python or JSON format file, which is generated by the Secure Build container when the container is created. The JSON format repository registration file can be used as the direct input to generate an encrypted repository definition file. Secondary node \u00b6 A cluster member that replicates the contents of the primary database in Hyper Protect DBaaS. Smart cards \u00b6 An HSM that looks like a credit card with an embedded chip. The chip is capable of performing a limited set of cryptographic operations and is loaded with custom software. Smart card readers \u00b6 A device that attaches to a workstation and allows the workstation to communicate with a smart card. Smart Card Utility Program \u00b6 The application installed as part of the Management Utilities. It sets up and manages the smart cards used by the Trusted Key Entry (TKE) application. Signature key \u00b6 An encryption key that is used by the crypto unit administrator to sign commands that are issued to the crypto unit. Standard key \u00b6 Another resources in Hyper Protect Crypto Services to directly encrypt and decrypt data. runc \u00b6 A CLI tool for spawning and running containers according to the Open Container Initiative (OCI) specification. runq \u00b6 An open-sourced hypervisor-based Docker runtime environment, which is based on runc to run regular containerized images in a lightweight KVM or Qemu virtual machine. s390x \u00b6 The underlying architecture of IBM Z or LinuxONE mainframe. Secure Build / Secure Image Build \u00b6 The process of building the application code from a Git-like source repository into a container image for s390x architecture, signing the image by using the authentication keys, and publishing the image to the remote repository for later integration. Secure Service Container \u00b6 A container framework based on the runq technology, that is supported by the IBM Z or LinuxONE servers. Secure Service Container partition \u00b6 A type of logic partitions (LPARs) on the mainframe that runs the Secure Service Container framework. SSH \u00b6 The abbreviation of Secure Shell, which is a cryptographic network protocol for operating network services securely over an unsecured network by using public and private keys. Storage Pool \u00b6 A storage pool is a uniquely named collection of storage disks on which the appliance file system is mounted. System Administrator \u00b6 This role includes the system administrator of a machine, storage administrators, and network administrators. tag \u00b6 A tag is used to version images in a repository. For example, latest, 1.2.3.4-develop-a0d3aea, or s390x-develop-54a9045. Trusted Key Entry application \u00b6 The application installed as part of the Management Utilities. It uses smart cards to load master keys in service instances and to perform other configuration tasks for service instances. Workload \u00b6 The application and data provided and generated by a (running) Workload Image. Workload Data \u00b6 Workload user or workload client data, workload logs, workload secrets stored in the appliance. Workload Image \u00b6 A container-based image, provided by the Workload Vendor. An appliance only runs workload images which have been registered with the appliance through a repository definition file. Workload User \u00b6 The end-user of a workload. Workload Vendor \u00b6 The creator of a Docker image running on top of Hosting Appliance.","title":"Glossary of terms"},{"location":"glossary/#appliance","text":"IBM Secure Service Container based appliance provided by an Appliance Vendor. From Hosting Appliance perspective, it is the combination of IBM Secure Service Container and the Hyper Protect Virtual Server Hosting Appliance.","title":"Appliance"},{"location":"glossary/#appliance-administrator","text":"The person administrating an appliance which includes tasks, such as configuring storage, or memory to the appliance or performing other configuration tasks through the API provided by SSC/the Hosting Appliance.","title":"Appliance Administrator"},{"location":"glossary/#appliance-operational-data","text":"Metrics, logs, appliance dump data, error logs, stack traces, kernel dump, etc.","title":"Appliance Operational Data"},{"location":"glossary/#appliance-protected-data","text":"Appliance secrets, workload data, configuration data, settings, and other internal information stored by an appliance.","title":"Appliance Protected Data"},{"location":"glossary/#appliance-vendor","text":"An internal, or external exploiter of SSC, packaging SSC into an appliance.","title":"Appliance Vendor"},{"location":"glossary/#byok","text":"The abbreviation of Bring Your Own Key, which allows you to import your existing keys to Hyper Protect Crypto Services service instances that protect your keys with advanced encryption.","title":"BYOK"},{"location":"glossary/#byoi","text":"The abbreviation of Bring Your Own Image, which is a part of IBM Hyper Protect Virtual Server solution to support the development and deployment of your own container images on top of the Secure Service Container framework.","title":"BYOI"},{"location":"glossary/#container","text":"A runtime instance of an Open Container Image (OCI) image.","title":"Container"},{"location":"glossary/#crypto-administrator","text":"The person who signs commands that are issued to the crypto units. Multiple administrators can be added to one crypto unit to increase security.","title":"Crypto administrator"},{"location":"glossary/#crypto-units","text":"A single unit that represents a hardware security module and the corresponding software stack that is dedicated to the hardware security module for cryptography.","title":"Crypto units"},{"location":"glossary/#data-encryption-keys","text":"A cryptographic key used to encrypt data that is stored in an application.","title":"Data encryption keys"},{"location":"glossary/#datapool","text":"Synonyms for Storage Pool.","title":"Datapool"},{"location":"glossary/#docker-content-trust","text":"Docker Content Trust (DCT) is a feature in the Docker containerization platform that provides the ability to use digital signatures for data sent to and received from remote Docker registries. These signatures allow client-side or runtime verification of the integrity and publisher of specific image tags. Through DCT, image publishers can sign their images and image consumers can ensure that the images they pull are signed. Publishers could be individuals or organizations manually signing their content or automated software supply chains signing content as part of their release process.","title":"Docker Content Trust"},{"location":"glossary/#docker-registry","text":"A Docker registry is a storage and content delivery system, holding named Docker images, available in different tagged versions.","title":"Docker registry"},{"location":"glossary/#ep11","text":"The abbreviation of Enterprise PKCS #11, which is specifically designed for customers seeking support for open standards and enhanced security. The EP11 library provides an interface very similar to the industry-standard PKCS #11 API.","title":"EP11"},{"location":"glossary/#envelope-encryption","text":"The process of encrypting data with a data encryption key and then encrypting the key with a root key that can be fully managed.","title":"Envelope encryption"},{"location":"glossary/#fips-140-2-compliance","text":"An organization\u2019s adherence to the Federal Information Processing Standards (FIPS) 140-2 standards. This standard specifies the security requirements that will be satisfied by a cryptographic module utilized within a security system protecting sensitive information. FIPS 140-2 outlines four levels of security: Level 1 - the lowest level of security. It covers the basic security features in a cryptographic module. Level 2 - improves the physical security aspects of cryptographic modules. Examples of required physical security measures are tamper-evident coatings, seals, or pick-resistant locks. Role-based authentication is included in this security level and ensures the operator accessing the module is authorized and is limited to their assigned actions. Level 3 - requires enhanced physical security, potentially with products available from the private sector. A multi-chip embedded module has to be contained in a strong enclosure that zeroizes critical security parameters when it is removed. This security level also uses identity-based authentication. Level 4 - requires tamper detection circuits to be able to detect any device penetration. This level is best for when cryptographic modules are in a physically unprotected environment that intruders can access. Modules must be able to detect fluctuations and zeroize themselves. Level 4 also protects against security compromises due to environmental conditions.","title":"FIPS 140-2 compliance"},{"location":"glossary/#fips-197-compliance","text":"An organization\u2019s adherence to Federal Information Processing Standards (FIPS) 197 which is an algorithmic standard that addresses the Advanced Encryption Standard (AES). AES specifies a FIPS-approved cryptographic algorithm that can be used to protect electronic data. The AES algorithm is a symmetric block cipher that can encrypt and decrypt information.","title":"FIPS 197 compliance"},{"location":"glossary/#gpg","text":"The abbreviation of Gnu Privacy Guard, which is an open standard used for signing, encrypting, and decrypting texts with public and private keys to increase the security of communications.","title":"GPG"},{"location":"glossary/#grep11","text":"Represents Enterprise PKCS #11 (EP11) APIs over gRPC calls, which is designed to be a stateless interface for cryptographic operations on cloud.","title":"GREP11"},{"location":"glossary/#grpc","text":"A modern open source high performance remote procedure call (RPC) framework that can connect services in and across data centers for load balancing, tracing, health checking, and authentication.","title":"gRPC"},{"location":"glossary/#hardware-security-module","text":"A physical appliance that provides on-demand encryption, key management, and key storage as a managed service.","title":"Hardware security module"},{"location":"glossary/#hosting-appliance","text":"A technical component within IBM Secure Service Container based appliances, providing the enablement for running Docker-based workloads.","title":"Hosting Appliance"},{"location":"glossary/#image","text":"The basis of the containers. An image is an ordered collection of root file system changes and the corresponding execution parameters for use within a container runtime.","title":"Image"},{"location":"glossary/#isv","text":"The abbreviation of Independent Software Vendor, who provides software solutions by developing and deploying containerized applications to the Secure Service Container partitions.","title":"ISV"},{"location":"glossary/#master-key","text":"An encryption key that is used to protect a crypto unit. The master key provides full control of the hardware security module and ownership of the root of trust that encrypts the chain keys, including the root key and standard key.","title":"Master key"},{"location":"glossary/#management-utilities","text":"A set of applications to provide an alternate way of configuring Hyper Protect Crypto Services service instances using signature keys and master key parts stored on smart cards.","title":"Management Utilities"},{"location":"glossary/#management-server","text":"An x86 or s390x Linux management server used to run the commands provided by the Hyper Protect Virtual Servers offering, and administer the offering.","title":"Management server"},{"location":"glossary/#manifest","text":"A manifest is generated by the Secure Build for audit purpose, which contains a copy of the github project cloned by the Secure Build container, a copy of the build log, and a build.json with the build status.","title":"Manifest"},{"location":"glossary/#manifest-public-key","text":"A manifest public key is used to verify the manifest generated by the Secure Build.","title":"Manifest public key"},{"location":"glossary/#manifest-private-key","text":"A manifest private key is used to sign the manifest during the Secure Build.","title":"Manifest private key"},{"location":"glossary/#mutual-tls","text":"Mutual authentication or two-way authentication refers to two parties authenticating each other at the same time. Mutual TLS is doing this over the TLS protocol.","title":"Mutual TLS"},{"location":"glossary/#namespace","text":"A namespace such as ibmzcontainers that contains a number of unique images. For examples, the images include hpvsop-base, hyperpcons-worker, hyperpcons-riaas, and so on.","title":"Namespace"},{"location":"glossary/#partition","text":"A partition is the logic partition (LPAR) on the mainframe, and can be created by using the logic partitioning tools such as Hardware Management Console (HMC) or other logical partitioning tools.","title":"Partition"},{"location":"glossary/#pkcs-11","text":"The abbreviation of Public-Key Cryptography Standards #11, which defines a platform-independent API to cryptographic tokens, such as HSM and smart cards.","title":"PKCS #11"},{"location":"glossary/#protected-memory-enclave","text":"Defined private regions of memory whose contents are protected and unable to be read or saved to any process outside the enclave itself.","title":"Protected memory enclave"},{"location":"glossary/#quotagroup","text":"The storage assigned to a workload running on an appliance. The appliance administrator assigns FCP, or ECKD based storage to an appliance. He then creates quotagroups, representing parts of the underlying storage. He finally assigns quotagroups to workloads through the appliance API.","title":"Quotagroup"},{"location":"glossary/#root-keys","text":"A symmetric wrapping key that is used for encrypting and decrypting other keys that are stored in a data service.","title":"Root keys"},{"location":"glossary/#registry","text":"A Registry is a hosted service containing repositories of container images that responds to the Registry API. For example, Docker Hub.","title":"Registry"},{"location":"glossary/#repository","text":"A repository is a set of containerized images. A repository can be shared by pushing it to a registry server. Different images in the repository can be labeled using tags. For example, hpvsop-base.","title":"Repository"},{"location":"glossary/#repository-definition-files","text":"An encrypted registration file or a repository definition file is used to register the repository, for authentication or validation reasons, such that a Hosting Appliance will trust that the image, when pulled from the registry, is authentic.","title":"Repository definition files"},{"location":"glossary/#repository-registration-files","text":"A cleartext Python or JSON format file, which is generated by the Secure Build container when the container is created. The JSON format repository registration file can be used as the direct input to generate an encrypted repository definition file.","title":"Repository registration files"},{"location":"glossary/#secondary-node","text":"A cluster member that replicates the contents of the primary database in Hyper Protect DBaaS.","title":"Secondary node"},{"location":"glossary/#smart-cards","text":"An HSM that looks like a credit card with an embedded chip. The chip is capable of performing a limited set of cryptographic operations and is loaded with custom software.","title":"Smart cards"},{"location":"glossary/#smart-card-readers","text":"A device that attaches to a workstation and allows the workstation to communicate with a smart card.","title":"Smart card readers"},{"location":"glossary/#smart-card-utility-program","text":"The application installed as part of the Management Utilities. It sets up and manages the smart cards used by the Trusted Key Entry (TKE) application.","title":"Smart Card Utility Program"},{"location":"glossary/#signature-key","text":"An encryption key that is used by the crypto unit administrator to sign commands that are issued to the crypto unit.","title":"Signature key"},{"location":"glossary/#standard-key","text":"Another resources in Hyper Protect Crypto Services to directly encrypt and decrypt data.","title":"Standard key"},{"location":"glossary/#runc","text":"A CLI tool for spawning and running containers according to the Open Container Initiative (OCI) specification.","title":"runc"},{"location":"glossary/#runq","text":"An open-sourced hypervisor-based Docker runtime environment, which is based on runc to run regular containerized images in a lightweight KVM or Qemu virtual machine.","title":"runq"},{"location":"glossary/#s390x","text":"The underlying architecture of IBM Z or LinuxONE mainframe.","title":"s390x"},{"location":"glossary/#secure-build-secure-image-build","text":"The process of building the application code from a Git-like source repository into a container image for s390x architecture, signing the image by using the authentication keys, and publishing the image to the remote repository for later integration.","title":"Secure Build / Secure Image Build"},{"location":"glossary/#secure-service-container","text":"A container framework based on the runq technology, that is supported by the IBM Z or LinuxONE servers.","title":"Secure Service Container"},{"location":"glossary/#secure-service-container-partition","text":"A type of logic partitions (LPARs) on the mainframe that runs the Secure Service Container framework.","title":"Secure Service Container partition"},{"location":"glossary/#ssh","text":"The abbreviation of Secure Shell, which is a cryptographic network protocol for operating network services securely over an unsecured network by using public and private keys.","title":"SSH"},{"location":"glossary/#storage-pool","text":"A storage pool is a uniquely named collection of storage disks on which the appliance file system is mounted.","title":"Storage Pool"},{"location":"glossary/#system-administrator","text":"This role includes the system administrator of a machine, storage administrators, and network administrators.","title":"System Administrator"},{"location":"glossary/#tag","text":"A tag is used to version images in a repository. For example, latest, 1.2.3.4-develop-a0d3aea, or s390x-develop-54a9045.","title":"tag"},{"location":"glossary/#trusted-key-entry-application","text":"The application installed as part of the Management Utilities. It uses smart cards to load master keys in service instances and to perform other configuration tasks for service instances.","title":"Trusted Key Entry application"},{"location":"glossary/#workload","text":"The application and data provided and generated by a (running) Workload Image.","title":"Workload"},{"location":"glossary/#workload-data","text":"Workload user or workload client data, workload logs, workload secrets stored in the appliance.","title":"Workload Data"},{"location":"glossary/#workload-image","text":"A container-based image, provided by the Workload Vendor. An appliance only runs workload images which have been registered with the appliance through a repository definition file.","title":"Workload Image"},{"location":"glossary/#workload-user","text":"The end-user of a workload.","title":"Workload User"},{"location":"glossary/#workload-vendor","text":"The creator of a Docker image running on top of Hosting Appliance.","title":"Workload Vendor"},{"location":"prerequisites/","text":"Prerequisites \u00b6 Create a GitHub \u00b6 Create a GitHub account (if you don't already have one) here . Create a Docker Hub \u00b6 Create a Docker Hub account (if you don't already have one) following the instructions here . Create a Docker access Token \u00b6 Create an access token for Docker Hub access during the lab (you will delete it if after finishing the lab) following the instructions here .","title":"Prerequisites"},{"location":"prerequisites/#prerequisites","text":"","title":"Prerequisites"},{"location":"prerequisites/#create-a-github","text":"Create a GitHub account (if you don't already have one) here .","title":"Create a GitHub"},{"location":"prerequisites/#create-a-docker-hub","text":"Create a Docker Hub account (if you don't already have one) following the instructions here .","title":"Create a Docker Hub"},{"location":"prerequisites/#create-a-docker-access-token","text":"Create an access token for Docker Hub access during the lab (you will delete it if after finishing the lab) following the instructions here .","title":"Create a Docker access Token"},{"location":"proposechange/","text":"How to propose a change \u00b6 On the page you want to make a change to, click on the pencil icon next to the page's title. This will take you to edit the page in Github. You will see a message similar to the following: \"You\u2019re editing a file in a project you don\u2019t have write access to. Submitting a change to this file will write it to a new branch in your fork, so you can send a pull request.\" Make your changes in Markdown. And submit for review. The owners of this repo will review your pull request and accept or deny your change proposal. There are other ways of doing a pull request, a Google search will lead you to those tutorials.","title":"Propose a change"},{"location":"proposechange/#how-to-propose-a-change","text":"On the page you want to make a change to, click on the pencil icon next to the page's title. This will take you to edit the page in Github. You will see a message similar to the following: \"You\u2019re editing a file in a project you don\u2019t have write access to. Submitting a change to this file will write it to a new branch in your fork, so you can send a pull request.\" Make your changes in Markdown. And submit for review. The owners of this repo will review your pull request and accept or deny your change proposal. There are other ways of doing a pull request, a Google search will lead you to those tutorials.","title":"How to propose a change"},{"location":"resources/","text":"Other Resources \u00b6 Hyper Protect Virtual Server Resources \u00b6 Knowledge Center Redbook Hyper Protect Resources \u00b6 IBM Cloud Hyper Protect Services Hyper Protect Digital Assets Platform","title":"Other resources"},{"location":"resources/#other-resources","text":"","title":"Other Resources"},{"location":"resources/#hyper-protect-virtual-server-resources","text":"Knowledge Center Redbook","title":"Hyper Protect Virtual Server Resources"},{"location":"resources/#hyper-protect-resources","text":"IBM Cloud Hyper Protect Services Hyper Protect Digital Assets Platform","title":"Hyper Protect Resources"},{"location":"securebuild-lab/assignment/","text":"","title":"Assignment"},{"location":"securebuild-lab/bitcoin_wallet/","text":"Use your bitcoin wallet application \u00b6 Overview \u00b6 This application is an secure Electrum Bitcoin wallet found at this GitHub repository . You can use it to store the identities necessary to transact on the Bitcoin public blockchain network. While this version of the wallet is just a proof of concept, running this type of wallet on Hyper Protect enables you to protect your digital assets from bad actors such as malicious server administrators. Info This Electrum Bitcoin wallet functions regularly, while inheriting the security benefits of the Hyper Protect Virtual Server platform. This ensures that a legitimate version of the application is running (Secure Image Build process) and that administrators cannot compromise the application (Hyper Protect Virtual Server deployment). Register a new user \u00b6 Get currency from a bitcoin test faucet \u00b6 Instead of transacting on the real bitcoin network we will use a testnet () https://bitcoinfaucet.uo1.net/send.php Send current back to the faucet \u00b6","title":"Use your Bitcoin Wallet"},{"location":"securebuild-lab/bitcoin_wallet/#use-your-bitcoin-wallet-application","text":"","title":"Use your bitcoin wallet application"},{"location":"securebuild-lab/bitcoin_wallet/#overview","text":"This application is an secure Electrum Bitcoin wallet found at this GitHub repository . You can use it to store the identities necessary to transact on the Bitcoin public blockchain network. While this version of the wallet is just a proof of concept, running this type of wallet on Hyper Protect enables you to protect your digital assets from bad actors such as malicious server administrators. Info This Electrum Bitcoin wallet functions regularly, while inheriting the security benefits of the Hyper Protect Virtual Server platform. This ensures that a legitimate version of the application is running (Secure Image Build process) and that administrators cannot compromise the application (Hyper Protect Virtual Server deployment).","title":"Overview"},{"location":"securebuild-lab/bitcoin_wallet/#register-a-new-user","text":"","title":"Register a new user"},{"location":"securebuild-lab/bitcoin_wallet/#get-currency-from-a-bitcoin-test-faucet","text":"Instead of transacting on the real bitcoin network we will use a testnet () https://bitcoinfaucet.uo1.net/send.php","title":"Get currency from a bitcoin test faucet"},{"location":"securebuild-lab/bitcoin_wallet/#send-current-back-to-the-faucet","text":"","title":"Send current back to the faucet"},{"location":"securebuild-lab/build/","text":"Securely Build your Application \u00b6 Export Variables set in previous sections to current terminal session \u00b6 Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\" Create repository registration GPG signing key \u00b6 Set key name Command Syntax export keyName = \"your_keyname\" Example Command export keyName = \"secure_bitcoin_key\" Set key passphrase Command Syntax export passphrase = \"your_passphrase\" Example Command export passphrase = \"most_secure_pw_i_could_think_of\" Create directory to store Docker repository registration signing key material mkdir -p \" ${ SB_DIR } /registration_keys\" Create Key Definition cat > \" ${ SB_DIR } /registration_keys/ ${ keyName } _definition_keys\" <<EOF %echo Generating registration definition key Key-Type: RSA Key-Length: 4096 Subkey-Type: RSA Subkey-Length: 4096 Name-Real: ${keyName} Expire-Date: 0 Passphrase: ${passphrase} # Do a commit here, so that we can later print \"done\" :-) %commit %echo done EOF Generate Key pair gpg --armor --batch \\ --generate-key \" ${ SB_DIR } /registration_keys/ ${ keyName } _definition_keys\" Example Output gpg: directory '/home/multiarch-lab/.gnupg' created gpg: keybox '/home/multiarch-lab/.gnupg/pubring.kbx' created gpg: Generating registration definition key gpg: /home/multiarch-lab/.gnupg/trustdb.gpg: trustdb created gpg: key 7E05CE05DFEBA2BC marked as ultimately trusted gpg: directory '/home/multiarch-lab/.gnupg/openpgp-revocs.d' created gpg: revocation certificate stored as '/home/multiarch-lab/.gnupg/openpgp-revocs.d/27FB55DC5F7FDF0598C9B1007E05CE05DFEBA2BC.rev' gpg: done Export Private key gpg --armor --pinentry-mode = loopback --passphrase \" ${ passphrase } \" \\ --export-secret-keys \" ${ keyName } \" > \" ${ SB_DIR } /registration_keys/ ${ keyName } .private\" Export Public key gpg --armor --export ${ keyName } > \" ${ SB_DIR } /registration_keys/ ${ keyName } .pub\" List newly generated key files ls ${ SB_DIR } /registration_keys/ Example Output secure_bitcoin_key_definition_keys secure_bitcoin_key.pub secure_bitcoin_key.private Set Build Configuration \u00b6 Set Secure Build Lab IP Address export SB_IP = 192 .168.22.120 Save Secure Build Lab IP Address for later use echo \"export SB_IP=' ${ SB_IP } '\" >> \" ${ HOME } /.bashrc\" Set Secure Build GitHub repository export GH_REPO = \"git@github.com:IBM/secure-bitcoin-wallet.git\" Set Docker Image Name export IMAGE_NAME = \"hpvs_bc\" Set repository registration name export REPO_ID = \" ${ IMAGE_NAME } _ ${ HPVS_NUMBER } \" Save repository registration name for later use echo \"export REPO_ID=' ${ REPO_ID } '\" >> \" ${ HOME } /.bashrc\" Create config file cat > \"${SB_DIR}/sb_config.yaml\" <<EOF secure_build_workers: sbs: url: 'https://${SB_IP}' port: '${SB_PORT}' cert_path: '${SB_DIR}/sbs_keys/sbs.cert' key_path: '${SB_DIR}/sbs_keys/sbs.key' regfile: id: '${REPO_ID}' github: url: '${GH_REPO}' branch: 'master' ssh_private_key_path: '${GITHUB_SSH_KEY}' recurse_submodules: 'False' dockerfile_path: './Dockerfile' docker_build_path: './' docker: push_server: '${REGISTRY_NAME}' #base_server: '${REGISTRY_NAME}' pull_server: '${REGISTRY_NAME}' repo: '${DOCKER_USERNAME}/${IMAGE_NAME}' image_tag_prefix: 'latest' content_trust_base: 'False' env: whitelist: [] build: args: [] signing_key: private_key_path: '${SB_DIR}/registration_keys/${keyName}.private' public_key_path: '${SB_DIR}/registration_keys/${keyName}.pub' EOF Build Application \u00b6 Launch secure build with a timeout of 20 minutes (1200 seconds) to complete using the above generated configuration file. echo \" ${ passphrase } \" | hpvs sb init \\ --config \" ${ SB_DIR } /sb_config.yaml\" \\ --out \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" --timeout 1200 --build Tip The following build will take anywhere from 15-20 minutes to complete. While this is ongoing, you should open a new tab in your terminal to check the automatically updating logs and build status (steps for doing this are detailed in the next few steps). Note The secure build is asynchronous so if the command gets interrupted here don't worry! That just means you will need to retrieve the registration file later since the cli couldn't grab it after the build. (We will do this anyway in Step 7 to cover our bases) Example Output after running 15-20 minutes to completion > --config \" ${ SB_DIR } /sb_config.yaml\" \\ > --out \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" --timeout 1200 --build Enter Sigining Private key passphrase: { \"status\" : \"OK\" } +--------+-------------------------+ | status | OK: async build started | +--------+-------------------------+ ############################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################## +---------------------+--------------------------------------------------------------------------------------------+ | root_ssh_enabled | false | | status | success | | build_name | docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641 | | image_tag | latest-b3416d8 | | manifest_key_gen | soft_crypto | | manifest_public_key | manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641-public.pem | +---------------------+--------------------------------------------------------------------------------------------+ Please look at the logs in another terminal window while the secure build is running (don't interrupt the current terminal window which is waiting for the secure build) hpvs sb log --config \" ${ SB_DIR } /sb_config.yaml\" Example Truncated Output 2020-06-23 05:25:42,453 root INFO starting a build 2020-06-23 05:25:42,454 root INFO cleaning up the local github repo and the github access credential 2020-06-23 05:25:42,454 root INFO github_dir=secure-bitcoin-wallet 2020-06-23 05:25:42,454 root INFO cloning a github repo 2020-06-23 05:25:42,454 root INFO github_host=github.com 2020-06-23 05:25:42,454 root INFO cmd=ssh-keyscan github.com 2020-06-23 05:25:47,659 root INFO # github.com:22 SSH-2.0-babeld-7c96ae41 # github.com:22 SSH-2.0-babeld-b6072416 # github.com:22 SSH-2.0-babeld-b6072416 github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pL ..... You can also look at the secure build status in another window. This can be useful if you accidentally interrupted the secure build command or it times out due to the timeout not being long enough. It will also fill out the additional fields that are initially blank when the build completes (such as build_name and manifest_public_key , etc.). hpvs sb status --config \" ${ SB_DIR } /sb_config.yaml\" Example Output +---------------------+---------------+ | manifest_public_key | | | root_ssh_enabled | false | | status | github cloned | | build_name | | | image_tag | | | manifest_key_gen | | +---------------------+---------------+ You can continue to check the logs to monitor the progress of your secure build with the previous logs command hpvs sb log --config \" ${ SB_DIR } /sb_config.yaml\" When the secure build successfully completes, it will have ending logs similar to the following: Example Output 2020 -06-23 08 :39:46,463 root INFO run: latest: digest: sha256:ffbaf396807659d5a4d66fe54c0ebf382a9f170c4eaf187b9b4c8582ca8fdec2 size: 5133 2020 -06-23 08 :39:46,463 root INFO run: Signing and pushing trust metadata 2020 -06-23 08 :39:48,299 root INFO run: Successfully signed docker.io/gmoney23/hpvs_bc:latest 2020 -06-23 08 :39:48,300 root INFO run: return code = 0 2020 -06-23 08 :39:48,300 root INFO extracting an image keyid and key 2020 -06-23 08 :39:48,301 root INFO keyid = 0cc264a565c452ea6aca776b2787be54e94b905113e77edae00d5ec267a07ffc 2020 -06-23 08 :39:48,301 root INFO publickey = LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJmVENDQVNTZ0F3SUJBZ0lSQUt3cTlRWEZhMzRYMXdIRmZST2NJZXN3Q2dZSUtvWkl6ajBFQXdJd0pURWoKTUNFR0ExVUVBd3dhWkc5amEyVnlMbWx2TDJkdGIyNWxlVEl6TDJod2RuTmZZbU13SGhjTk1qQXdOakl6TURnegpPVFF4V2hjTk16QXdOakl4TURnek9UUXhXakFsTVNNd0lRWURWUVFEREJwa2IyTnJaWEl1YVc4dloyMXZibVY1Ck1qTXZhSEIyYzE5aVl6QlpNQk1HQnlxR1NNNDlBZ0VHQ0NxR1NNNDlBd0VIQTBJQUJKU3ZPdWlSaHJNcjJmQVYKcmZLcHZncVRYNXZwSFlodnEvZXc1SFRuMzRMcnBrQ0xJMjBkdmxjcTUyc1ZvQjVxYkpzeEdTbkphOU5sM0tYYQpZUlRjQ2Z1ak5UQXpNQTRHQTFVZER3RUIvd1FFQXdJRm9EQVRCZ05WSFNVRUREQUtCZ2dyQmdFRkJRY0RBekFNCkJnTlZIUk1CQWY4RUFqQUFNQW9HQ0NxR1NNNDlCQU1DQTBjQU1FUUNJRlhFWE9iZTdHR1NsSjEzTzZicTR6T0IKamhoMlZSbmRYOVJYMytrSFpnVVVBaUJBWXAyNTkwTkpVelJIK1lhR2JzQ1hMRmxOUWRzT2ltWW9NMzlqR0IwRAp5dz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K 2020 -06-23 08 :39:48,301 root INFO generating a config file 2020 -06-23 08 :39:48,301 root INFO create_and_push: SoftCrypto 2020 -06-23 08 :39:48,819 root INFO digest = 1f0b1f65b1462f16930b200c77ce5fbe654e1d624405bc243d713de1aade36b7 2020 -06-23 08 :39:48,819 root INFO block_size = 64 2020 -06-23 08 :39:48,821 root INFO digest = 1f0b1f65b1462f16930b200c77ce5fbe654e1d624405bc243d713de1aade36b7 2020 -06-23 08 :39:48,824 root INFO signature = 114157a8bd98d7f5a5c2ca33f81496563af7f18d23123fc35c8aa84a5bfadc709ecb17e5e79d42d6bd6ac8a815053d9cfd039b7f01ab84b9a75a23e2917b0bc4f0c1b5bd5664dfebd573c2355c34115762b8fea56285d65cd8db4877c9b95ab3149b65d14ce1a23b1065a34c2d4ba9a1526286a03d87d307a5972cf1425e586c9d213b34fe53407c79a527e78779b7a70b426516db35f22a09329dfac76a8505613249ad2b46070ad7d932a8c4bbe1981d0370150528cb9e6f5a426be6734405435393a8d6d8e145418398f85bc28be6c332d2fa2e84f5465618051b110a3efcd25600dc95ee0d7f8bc0d36b8ddaa9ce1c4be78f38928d9213e5171078e22930 2020 -06-23 08 :39:48,824 root INFO verify = OK 2020 -06-23 08 :39:49,214 root WARNING undefined MANIFEST_BUCKET_NAME 2020 -06-23 08 :39:49,214 root WARNING skipping transferring a manifest to COS 2020 -06-23 08 :39:49,214 root INFO cleaning up the build environment 2020 -06-23 08 :39:49,214 root INFO github_dir = secure-bitcoin-wallet 2020 -06-23 08 :39:49,217 root INFO completed a build When the secure build successfully completes, you can check the status again to see a completed status. hpvs sb status --config \" ${ SB_DIR } /sb_config.yaml\" Example Output +---------------------+------------------------------------------------------------------------------------------+ | build_name | docker.io.gmoney23.hpvs_bc.latest-b3416d8.2020-06-23_08-39-48.301849 | | image_tag | latest-b3416d8 | | manifest_key_gen | soft_crypto | | manifest_public_key | manifest.docker.io.gmoney23.hpvs_bc.latest-b3416d8.2020-06-23_08-39-48.301849-public.pem | | root_ssh_enabled | false | | status | success | +---------------------+------------------------------------------------------------------------------------------+ From the original terminal window that you ran hpvs sb init , output the repository registration file (just in case the sb init command got interrupted before completing) echo \" ${ passphrase } \" | hpvs sb regfile \\ --config \" ${ SB_DIR } /sb_config.yaml\" \\ --out \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" Example Output Enter Sigining Private key passphrase: Tip The echo command takes care of the passphrase so you don't need to enter it manually. Warning If you run this command from a terminal window where you did not set the $passphrase environment variable you will get an error saying openpgp: invalid data: private key checksum failure . You can also check to make sure you are in the right terminal window by running echo $passphrase and the output should be the passphrase you set in the beginning of the \"Create repository registration GPG signing key\" section. Note This registration file should be created at the end of the sb init command. However, given that the build is asynchronous it will complete even if you accidentally interrupt it. However, if you do interrupt it then the repository registration file won't be created. We grab it again here just to cover our bases if that command got interrupted. If it didn't get interrupted you could skip this step. However, it doesn't hurt to grab it again here as it will just retrieve it again. Verify your application \u00b6 Create directories for your manifest file information and change into your new manifest directory. mkdir -p \" ${ SB_DIR } /manifest/manifest_files\" && cd \" ${ SB_DIR } /manifest\" Save the build name from the status command as a variable export BUILD_NAME = \" $( hpvs sb status --config \" ${ SB_DIR } /sb_config.yaml\" \\ | grep build_name | egrep -ow 'docker.*[[:digit:]]' ) \" && echo \" ${ BUILD_NAME } \" Example Output docker.io.gmoney23.hpvs_bc.latest-b3416d8.2020-06-23_08-39-48.301849 Get your application manifest hpvs sb manifest --config \" ${ SB_DIR } /sb_config.yaml\" --name \" ${ BUILD_NAME } \" Get your manifest public verification key hpvs sb pubkey --config \" ${ SB_DIR } /sb_config.yaml\" --name \" ${ BUILD_NAME } \" Check that your application manifest and signing key were retrieved ls Example Output docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641-public.pem manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641.sig.tbz manifest_files Set MANIFEST to point to your manifest files. export MANIFEST = \" ${ SB_DIR } /manifest/manifest. ${ BUILD_NAME } \" Set MAN_KEY to point to your manifest public key. export MAN_KEY = \" ${ SB_DIR } /manifest/ ${ MAN_KEY } -public.pem\" Untar and unzip the manifest .sig.tbz file to reveal the .sig and .tbz files (and remove the original .sig.tbz ) tar -xjvf \" ${ MANIFEST } .sig.tbz\" && rm \" ${ MANIFEST } .sig.tbz\" Example Output manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641.tbz manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641.sig Note The .sig.tbz was a tarball compressed using bzip2 compression of both a nested .tbz file (containing the manifest files) and a .sig file containing a signature of the nested .tbz to verify it with the public key retrieved using the hpvs sb pubkey command above saved in the file referenced by MAN_KEY . Untar and unzip the manifest .tbz file into the manifest_files directory. tar -xjf \" ${ MANIFEST } .tbz\" -C \" ${ SB_DIR } /manifest/manifest_files\" Change into the manifest_files directory with your manifest files and view the files in the directory. cd \" ${ SB_DIR } /manifest/manifest_files\" && ls Example Output data git root_ssh Manifest explanation This manifest package contains three directories as shown above. The data directory contains the build.json (containing the build status of the directory updated after the image was pushed to its Docker Registry) and build.log (containing the logs from the secure build). The git directory contains the source code used for the build (cloned from git). Finally, the root_ssh directory contains any ssh material provided (if the user chose to use ssh) which is empty for us because we didn't enable ssh and provide ssh keys. This way no one can ssh into our secure build container. What does this give me? This gives you a way to see the collection of files used for your build at the time of the build and signed by the manifest private key which is secured in your secure build container. By retrieving the public key and verifying the signature of the package we and auditors can verify what was used for our secure image build. (Since the private key was generated in the secure build server we can trust it) This gives us verification of what was used in the build as well as the verification of the images themselves we get from Docker Content Trust . Note The secure build server also generates the keys for Docker Content Trust and stores them safely to provide a secure root of trust. Remember the secure build server is running as a Hyper Protect Virtual Server and thus inherits all of the security features and assurances of Hyper Protect Virtual Servers. Summary \u00b6 Congratulations!!! You have securely built your application and are ready to deploy it into a Hyper Protect Virtual Server in the next section.","title":"Securely Build your Image"},{"location":"securebuild-lab/build/#securely-build-your-application","text":"","title":"Securely Build your Application"},{"location":"securebuild-lab/build/#export-variables-set-in-previous-sections-to-current-terminal-session","text":"Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\"","title":"Export Variables set in previous sections to current terminal session"},{"location":"securebuild-lab/build/#create-repository-registration-gpg-signing-key","text":"Set key name Command Syntax export keyName = \"your_keyname\" Example Command export keyName = \"secure_bitcoin_key\" Set key passphrase Command Syntax export passphrase = \"your_passphrase\" Example Command export passphrase = \"most_secure_pw_i_could_think_of\" Create directory to store Docker repository registration signing key material mkdir -p \" ${ SB_DIR } /registration_keys\" Create Key Definition cat > \" ${ SB_DIR } /registration_keys/ ${ keyName } _definition_keys\" <<EOF %echo Generating registration definition key Key-Type: RSA Key-Length: 4096 Subkey-Type: RSA Subkey-Length: 4096 Name-Real: ${keyName} Expire-Date: 0 Passphrase: ${passphrase} # Do a commit here, so that we can later print \"done\" :-) %commit %echo done EOF Generate Key pair gpg --armor --batch \\ --generate-key \" ${ SB_DIR } /registration_keys/ ${ keyName } _definition_keys\" Example Output gpg: directory '/home/multiarch-lab/.gnupg' created gpg: keybox '/home/multiarch-lab/.gnupg/pubring.kbx' created gpg: Generating registration definition key gpg: /home/multiarch-lab/.gnupg/trustdb.gpg: trustdb created gpg: key 7E05CE05DFEBA2BC marked as ultimately trusted gpg: directory '/home/multiarch-lab/.gnupg/openpgp-revocs.d' created gpg: revocation certificate stored as '/home/multiarch-lab/.gnupg/openpgp-revocs.d/27FB55DC5F7FDF0598C9B1007E05CE05DFEBA2BC.rev' gpg: done Export Private key gpg --armor --pinentry-mode = loopback --passphrase \" ${ passphrase } \" \\ --export-secret-keys \" ${ keyName } \" > \" ${ SB_DIR } /registration_keys/ ${ keyName } .private\" Export Public key gpg --armor --export ${ keyName } > \" ${ SB_DIR } /registration_keys/ ${ keyName } .pub\" List newly generated key files ls ${ SB_DIR } /registration_keys/ Example Output secure_bitcoin_key_definition_keys secure_bitcoin_key.pub secure_bitcoin_key.private","title":"Create repository registration GPG signing key"},{"location":"securebuild-lab/build/#set-build-configuration","text":"Set Secure Build Lab IP Address export SB_IP = 192 .168.22.120 Save Secure Build Lab IP Address for later use echo \"export SB_IP=' ${ SB_IP } '\" >> \" ${ HOME } /.bashrc\" Set Secure Build GitHub repository export GH_REPO = \"git@github.com:IBM/secure-bitcoin-wallet.git\" Set Docker Image Name export IMAGE_NAME = \"hpvs_bc\" Set repository registration name export REPO_ID = \" ${ IMAGE_NAME } _ ${ HPVS_NUMBER } \" Save repository registration name for later use echo \"export REPO_ID=' ${ REPO_ID } '\" >> \" ${ HOME } /.bashrc\" Create config file cat > \"${SB_DIR}/sb_config.yaml\" <<EOF secure_build_workers: sbs: url: 'https://${SB_IP}' port: '${SB_PORT}' cert_path: '${SB_DIR}/sbs_keys/sbs.cert' key_path: '${SB_DIR}/sbs_keys/sbs.key' regfile: id: '${REPO_ID}' github: url: '${GH_REPO}' branch: 'master' ssh_private_key_path: '${GITHUB_SSH_KEY}' recurse_submodules: 'False' dockerfile_path: './Dockerfile' docker_build_path: './' docker: push_server: '${REGISTRY_NAME}' #base_server: '${REGISTRY_NAME}' pull_server: '${REGISTRY_NAME}' repo: '${DOCKER_USERNAME}/${IMAGE_NAME}' image_tag_prefix: 'latest' content_trust_base: 'False' env: whitelist: [] build: args: [] signing_key: private_key_path: '${SB_DIR}/registration_keys/${keyName}.private' public_key_path: '${SB_DIR}/registration_keys/${keyName}.pub' EOF","title":"Set Build Configuration"},{"location":"securebuild-lab/build/#build-application","text":"Launch secure build with a timeout of 20 minutes (1200 seconds) to complete using the above generated configuration file. echo \" ${ passphrase } \" | hpvs sb init \\ --config \" ${ SB_DIR } /sb_config.yaml\" \\ --out \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" --timeout 1200 --build Tip The following build will take anywhere from 15-20 minutes to complete. While this is ongoing, you should open a new tab in your terminal to check the automatically updating logs and build status (steps for doing this are detailed in the next few steps). Note The secure build is asynchronous so if the command gets interrupted here don't worry! That just means you will need to retrieve the registration file later since the cli couldn't grab it after the build. (We will do this anyway in Step 7 to cover our bases) Example Output after running 15-20 minutes to completion > --config \" ${ SB_DIR } /sb_config.yaml\" \\ > --out \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" --timeout 1200 --build Enter Sigining Private key passphrase: { \"status\" : \"OK\" } +--------+-------------------------+ | status | OK: async build started | +--------+-------------------------+ ############################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################## +---------------------+--------------------------------------------------------------------------------------------+ | root_ssh_enabled | false | | status | success | | build_name | docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641 | | image_tag | latest-b3416d8 | | manifest_key_gen | soft_crypto | | manifest_public_key | manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641-public.pem | +---------------------+--------------------------------------------------------------------------------------------+ Please look at the logs in another terminal window while the secure build is running (don't interrupt the current terminal window which is waiting for the secure build) hpvs sb log --config \" ${ SB_DIR } /sb_config.yaml\" Example Truncated Output 2020-06-23 05:25:42,453 root INFO starting a build 2020-06-23 05:25:42,454 root INFO cleaning up the local github repo and the github access credential 2020-06-23 05:25:42,454 root INFO github_dir=secure-bitcoin-wallet 2020-06-23 05:25:42,454 root INFO cloning a github repo 2020-06-23 05:25:42,454 root INFO github_host=github.com 2020-06-23 05:25:42,454 root INFO cmd=ssh-keyscan github.com 2020-06-23 05:25:47,659 root INFO # github.com:22 SSH-2.0-babeld-7c96ae41 # github.com:22 SSH-2.0-babeld-b6072416 # github.com:22 SSH-2.0-babeld-b6072416 github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pL ..... You can also look at the secure build status in another window. This can be useful if you accidentally interrupted the secure build command or it times out due to the timeout not being long enough. It will also fill out the additional fields that are initially blank when the build completes (such as build_name and manifest_public_key , etc.). hpvs sb status --config \" ${ SB_DIR } /sb_config.yaml\" Example Output +---------------------+---------------+ | manifest_public_key | | | root_ssh_enabled | false | | status | github cloned | | build_name | | | image_tag | | | manifest_key_gen | | +---------------------+---------------+ You can continue to check the logs to monitor the progress of your secure build with the previous logs command hpvs sb log --config \" ${ SB_DIR } /sb_config.yaml\" When the secure build successfully completes, it will have ending logs similar to the following: Example Output 2020 -06-23 08 :39:46,463 root INFO run: latest: digest: sha256:ffbaf396807659d5a4d66fe54c0ebf382a9f170c4eaf187b9b4c8582ca8fdec2 size: 5133 2020 -06-23 08 :39:46,463 root INFO run: Signing and pushing trust metadata 2020 -06-23 08 :39:48,299 root INFO run: Successfully signed docker.io/gmoney23/hpvs_bc:latest 2020 -06-23 08 :39:48,300 root INFO run: return code = 0 2020 -06-23 08 :39:48,300 root INFO extracting an image keyid and key 2020 -06-23 08 :39:48,301 root INFO keyid = 0cc264a565c452ea6aca776b2787be54e94b905113e77edae00d5ec267a07ffc 2020 -06-23 08 :39:48,301 root INFO publickey = LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJmVENDQVNTZ0F3SUJBZ0lSQUt3cTlRWEZhMzRYMXdIRmZST2NJZXN3Q2dZSUtvWkl6ajBFQXdJd0pURWoKTUNFR0ExVUVBd3dhWkc5amEyVnlMbWx2TDJkdGIyNWxlVEl6TDJod2RuTmZZbU13SGhjTk1qQXdOakl6TURnegpPVFF4V2hjTk16QXdOakl4TURnek9UUXhXakFsTVNNd0lRWURWUVFEREJwa2IyTnJaWEl1YVc4dloyMXZibVY1Ck1qTXZhSEIyYzE5aVl6QlpNQk1HQnlxR1NNNDlBZ0VHQ0NxR1NNNDlBd0VIQTBJQUJKU3ZPdWlSaHJNcjJmQVYKcmZLcHZncVRYNXZwSFlodnEvZXc1SFRuMzRMcnBrQ0xJMjBkdmxjcTUyc1ZvQjVxYkpzeEdTbkphOU5sM0tYYQpZUlRjQ2Z1ak5UQXpNQTRHQTFVZER3RUIvd1FFQXdJRm9EQVRCZ05WSFNVRUREQUtCZ2dyQmdFRkJRY0RBekFNCkJnTlZIUk1CQWY4RUFqQUFNQW9HQ0NxR1NNNDlCQU1DQTBjQU1FUUNJRlhFWE9iZTdHR1NsSjEzTzZicTR6T0IKamhoMlZSbmRYOVJYMytrSFpnVVVBaUJBWXAyNTkwTkpVelJIK1lhR2JzQ1hMRmxOUWRzT2ltWW9NMzlqR0IwRAp5dz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K 2020 -06-23 08 :39:48,301 root INFO generating a config file 2020 -06-23 08 :39:48,301 root INFO create_and_push: SoftCrypto 2020 -06-23 08 :39:48,819 root INFO digest = 1f0b1f65b1462f16930b200c77ce5fbe654e1d624405bc243d713de1aade36b7 2020 -06-23 08 :39:48,819 root INFO block_size = 64 2020 -06-23 08 :39:48,821 root INFO digest = 1f0b1f65b1462f16930b200c77ce5fbe654e1d624405bc243d713de1aade36b7 2020 -06-23 08 :39:48,824 root INFO signature = 114157a8bd98d7f5a5c2ca33f81496563af7f18d23123fc35c8aa84a5bfadc709ecb17e5e79d42d6bd6ac8a815053d9cfd039b7f01ab84b9a75a23e2917b0bc4f0c1b5bd5664dfebd573c2355c34115762b8fea56285d65cd8db4877c9b95ab3149b65d14ce1a23b1065a34c2d4ba9a1526286a03d87d307a5972cf1425e586c9d213b34fe53407c79a527e78779b7a70b426516db35f22a09329dfac76a8505613249ad2b46070ad7d932a8c4bbe1981d0370150528cb9e6f5a426be6734405435393a8d6d8e145418398f85bc28be6c332d2fa2e84f5465618051b110a3efcd25600dc95ee0d7f8bc0d36b8ddaa9ce1c4be78f38928d9213e5171078e22930 2020 -06-23 08 :39:48,824 root INFO verify = OK 2020 -06-23 08 :39:49,214 root WARNING undefined MANIFEST_BUCKET_NAME 2020 -06-23 08 :39:49,214 root WARNING skipping transferring a manifest to COS 2020 -06-23 08 :39:49,214 root INFO cleaning up the build environment 2020 -06-23 08 :39:49,214 root INFO github_dir = secure-bitcoin-wallet 2020 -06-23 08 :39:49,217 root INFO completed a build When the secure build successfully completes, you can check the status again to see a completed status. hpvs sb status --config \" ${ SB_DIR } /sb_config.yaml\" Example Output +---------------------+------------------------------------------------------------------------------------------+ | build_name | docker.io.gmoney23.hpvs_bc.latest-b3416d8.2020-06-23_08-39-48.301849 | | image_tag | latest-b3416d8 | | manifest_key_gen | soft_crypto | | manifest_public_key | manifest.docker.io.gmoney23.hpvs_bc.latest-b3416d8.2020-06-23_08-39-48.301849-public.pem | | root_ssh_enabled | false | | status | success | +---------------------+------------------------------------------------------------------------------------------+ From the original terminal window that you ran hpvs sb init , output the repository registration file (just in case the sb init command got interrupted before completing) echo \" ${ passphrase } \" | hpvs sb regfile \\ --config \" ${ SB_DIR } /sb_config.yaml\" \\ --out \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" Example Output Enter Sigining Private key passphrase: Tip The echo command takes care of the passphrase so you don't need to enter it manually. Warning If you run this command from a terminal window where you did not set the $passphrase environment variable you will get an error saying openpgp: invalid data: private key checksum failure . You can also check to make sure you are in the right terminal window by running echo $passphrase and the output should be the passphrase you set in the beginning of the \"Create repository registration GPG signing key\" section. Note This registration file should be created at the end of the sb init command. However, given that the build is asynchronous it will complete even if you accidentally interrupt it. However, if you do interrupt it then the repository registration file won't be created. We grab it again here just to cover our bases if that command got interrupted. If it didn't get interrupted you could skip this step. However, it doesn't hurt to grab it again here as it will just retrieve it again.","title":"Build Application"},{"location":"securebuild-lab/build/#verify-your-application","text":"Create directories for your manifest file information and change into your new manifest directory. mkdir -p \" ${ SB_DIR } /manifest/manifest_files\" && cd \" ${ SB_DIR } /manifest\" Save the build name from the status command as a variable export BUILD_NAME = \" $( hpvs sb status --config \" ${ SB_DIR } /sb_config.yaml\" \\ | grep build_name | egrep -ow 'docker.*[[:digit:]]' ) \" && echo \" ${ BUILD_NAME } \" Example Output docker.io.gmoney23.hpvs_bc.latest-b3416d8.2020-06-23_08-39-48.301849 Get your application manifest hpvs sb manifest --config \" ${ SB_DIR } /sb_config.yaml\" --name \" ${ BUILD_NAME } \" Get your manifest public verification key hpvs sb pubkey --config \" ${ SB_DIR } /sb_config.yaml\" --name \" ${ BUILD_NAME } \" Check that your application manifest and signing key were retrieved ls Example Output docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641-public.pem manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641.sig.tbz manifest_files Set MANIFEST to point to your manifest files. export MANIFEST = \" ${ SB_DIR } /manifest/manifest. ${ BUILD_NAME } \" Set MAN_KEY to point to your manifest public key. export MAN_KEY = \" ${ SB_DIR } /manifest/ ${ MAN_KEY } -public.pem\" Untar and unzip the manifest .sig.tbz file to reveal the .sig and .tbz files (and remove the original .sig.tbz ) tar -xjvf \" ${ MANIFEST } .sig.tbz\" && rm \" ${ MANIFEST } .sig.tbz\" Example Output manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641.tbz manifest.docker.io.gmoney23.hpvs_bc_a.latest-b3416d8.2020-06-23_22-12-54.183641.sig Note The .sig.tbz was a tarball compressed using bzip2 compression of both a nested .tbz file (containing the manifest files) and a .sig file containing a signature of the nested .tbz to verify it with the public key retrieved using the hpvs sb pubkey command above saved in the file referenced by MAN_KEY . Untar and unzip the manifest .tbz file into the manifest_files directory. tar -xjf \" ${ MANIFEST } .tbz\" -C \" ${ SB_DIR } /manifest/manifest_files\" Change into the manifest_files directory with your manifest files and view the files in the directory. cd \" ${ SB_DIR } /manifest/manifest_files\" && ls Example Output data git root_ssh Manifest explanation This manifest package contains three directories as shown above. The data directory contains the build.json (containing the build status of the directory updated after the image was pushed to its Docker Registry) and build.log (containing the logs from the secure build). The git directory contains the source code used for the build (cloned from git). Finally, the root_ssh directory contains any ssh material provided (if the user chose to use ssh) which is empty for us because we didn't enable ssh and provide ssh keys. This way no one can ssh into our secure build container. What does this give me? This gives you a way to see the collection of files used for your build at the time of the build and signed by the manifest private key which is secured in your secure build container. By retrieving the public key and verifying the signature of the package we and auditors can verify what was used for our secure image build. (Since the private key was generated in the secure build server we can trust it) This gives us verification of what was used in the build as well as the verification of the images themselves we get from Docker Content Trust . Note The secure build server also generates the keys for Docker Content Trust and stores them safely to provide a secure root of trust. Remember the secure build server is running as a Hyper Protect Virtual Server and thus inherits all of the security features and assurances of Hyper Protect Virtual Servers.","title":"Verify your application"},{"location":"securebuild-lab/build/#summary","text":"Congratulations!!! You have securely built your application and are ready to deploy it into a Hyper Protect Virtual Server in the next section.","title":"Summary"},{"location":"securebuild-lab/cleanup/","text":"Clean up Instructions \u00b6 Export Variables set in previous sections to current terminal session \u00b6 Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\" Cleanup Secure Build Server \u00b6 Cleanup virtual server hpvs vs delete --name sbserver_ ${ HPVS_NUMBER } Cleanup Quotagroup hpvs quotagroup delete --name \"sb_user ${ HPVS_NUMBER } \" Cleanup Application \u00b6 Cleanup HPVS deployment hpvs vs delete --name ${ REPO_ID } Cleanup Quotagroup hpvs quotagroup delete --name \" ${ REPO_ID } \" Cleanup Repository \u00b6 hpvs repository delete --id ${ REPO_ID } Example Output +-------------------+-----------------------------------------------------------------------------------------------------------------------------+ | ContainersDeleted | [] | | ImagesDeleted | map [ Deleted: [ sha256:5c0129df1b5ccb333a4dea9ed5a880cbc15654a9c1d5e32bb4e183072ce7b021 ] Untagged: [ gmoney23/hpvs_bc_a:latest ]] | | RepositoryDeleted | docker.io/gmoney23/hpvs_bc_a | +-------------------+-----------------------------------------------------------------------------------------------------------------------------+ Cleanup Docker Token \u00b6 Delete the existing Docker Token by logging into your Docker Hub account and following these instructions Cleanup GitHub ssh key \u00b6 Delete the ssh key you added for the lab following steps 1-3 of these instructions Cleanup Lab directory \u00b6 You can remove the directory you stored your files in throughout the lab. This is a personal choice as the lab machine will be deleted after the lab anyway. rm -rf \" ${ SB_DIR } \"","title":"Clean up your Environment"},{"location":"securebuild-lab/cleanup/#clean-up-instructions","text":"","title":"Clean up Instructions"},{"location":"securebuild-lab/cleanup/#export-variables-set-in-previous-sections-to-current-terminal-session","text":"Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\"","title":"Export Variables set in previous sections to current terminal session"},{"location":"securebuild-lab/cleanup/#cleanup-secure-build-server","text":"Cleanup virtual server hpvs vs delete --name sbserver_ ${ HPVS_NUMBER } Cleanup Quotagroup hpvs quotagroup delete --name \"sb_user ${ HPVS_NUMBER } \"","title":"Cleanup Secure Build Server"},{"location":"securebuild-lab/cleanup/#cleanup-application","text":"Cleanup HPVS deployment hpvs vs delete --name ${ REPO_ID } Cleanup Quotagroup hpvs quotagroup delete --name \" ${ REPO_ID } \"","title":"Cleanup Application"},{"location":"securebuild-lab/cleanup/#cleanup-repository","text":"hpvs repository delete --id ${ REPO_ID } Example Output +-------------------+-----------------------------------------------------------------------------------------------------------------------------+ | ContainersDeleted | [] | | ImagesDeleted | map [ Deleted: [ sha256:5c0129df1b5ccb333a4dea9ed5a880cbc15654a9c1d5e32bb4e183072ce7b021 ] Untagged: [ gmoney23/hpvs_bc_a:latest ]] | | RepositoryDeleted | docker.io/gmoney23/hpvs_bc_a | +-------------------+-----------------------------------------------------------------------------------------------------------------------------+","title":"Cleanup Repository"},{"location":"securebuild-lab/cleanup/#cleanup-docker-token","text":"Delete the existing Docker Token by logging into your Docker Hub account and following these instructions","title":"Cleanup Docker Token"},{"location":"securebuild-lab/cleanup/#cleanup-github-ssh-key","text":"Delete the ssh key you added for the lab following steps 1-3 of these instructions","title":"Cleanup GitHub ssh key"},{"location":"securebuild-lab/cleanup/#cleanup-lab-directory","text":"You can remove the directory you stored your files in throughout the lab. This is a personal choice as the lab machine will be deleted after the lab anyway. rm -rf \" ${ SB_DIR } \"","title":"Cleanup Lab directory"},{"location":"securebuild-lab/create-server/","text":"Create Secure Build Hyper Protect Virtual Server \u00b6 Export Variables set in previous sections to current terminal session \u00b6 Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\" Create Certificate and Key for mutual tls \u00b6 Generate rand file openssl rand -out \" ${ HOME } /.rnd\" -hex 256 Make SB_DIR/sbs_keys directory to store secure build server keys. mkdir -p \" ${ SB_DIR } /sbs_keys\" Generate cert and key to use mutual tls openssl req -newkey rsa:2048 \\ -new -nodes -x509 \\ -days 3650 \\ -out \" ${ SB_DIR } /sbs_keys/sbs.cert\" \\ -keyout \" ${ SB_DIR } /sbs_keys/sbs.key\" \\ -subj \"/C=US/O=IBM/CN=hpvs.example.com\" Example Output Generating a RSA private key ................................+++++ ...............................+++++ writing new private key to '/home/multiarch-lab/securebuild-lab/sbs_keys/sbs.key' ----- Change cert to base64 encoding and save to new file. echo $( cat \" ${ SB_DIR } /sbs_keys/sbs.cert\" | base64 ) \\ | tr -d ' ' >> \" ${ SB_DIR } /sbs_keys/sbs_base64.cert\" Save the cert as an environment variable export cert = $( cat \" ${ SB_DIR } /sbs_keys/sbs_base64.cert\" ) Set your provided number and save it for later use \u00b6 You will be assigned a number for the lab so as not to interfere with other users. Note This table tells you which number you are assigned. Set the HPVS_NUMBER variable with your assigned 2 digit number Command Syntax export HPVS_NUMBER = \"your_assigned_number\" Example Command export HPVS_NUMBER = \"00\" Warning Your user will NOT be 00 . Please set the appropriate user you have been assigned. Save your number to bashrc for later use. echo \"export HPVS_NUMBER=' ${ HPVS_NUMBER } '\" >> \" ${ HOME } /.bashrc\" 3. Set Secure Build Server Port export SB_PORT = 300 ${ HPVS_NUMBER } Save SB_PORT to bashrc for later use. echo \"export SB_PORT=' ${ SB_PORT } '\" >> \" ${ HOME } /.bashrc\" Create Quotagroup with storage for secure build server \u00b6 hpvs quotagroup create --name \"sb_user ${ HPVS_NUMBER } \" --size = 30GB Example Ouput +-------------+--------------+ | name | sb_user00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 30GB | | available | 30GB | | containers | [] | +-------------+--------------+ Create Securebuild server \u00b6 hpvs vs create --name sbserver_ ${ HPVS_NUMBER } --repo SecureDockerBuild \\ --tag 1 .2.1-release-9b63b43 --cpu 2 --ram 2048 \\ --quotagroup \"{quotagroup = sb_user ${ HPVS_NUMBER } , mountid = new, mount = /newroot, filesystem = ext4, size = 10GB}\" \\ --quotagroup \"{quotagroup = sb_user ${ HPVS_NUMBER } , mountid = data, mount = /data, filesystem = ext4, size = 2GB}\" \\ --quotagroup \"{quotagroup = sb_user ${ HPVS_NUMBER } , mountid = docker, mount = /docker, filesystem = ext4, size = 16GB}\" \\ --env ={ EX_VOLUMES = \"/docker,/data\" ,ROOTFS_LOCK = y,CLIENT_CRT = $cert } \\ --ports \"{containerport = 443, protocol = tcp, hostport = ${ SB_PORT } }\" Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 sbserver_00 \u2502 \u2502 Status \u2502 Up Less than a second \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.5 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:05 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30000 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 sb_user00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f We can see the quotagroup is now being used with hpvs quotagroup show --name \"sb_user ${ HPVS_NUMBER } \" Example Output +-------------+--------------------------------+ | PROPERTIES | VALUES | +-------------+--------------------------------+ | name | sb_user00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 30GB | | available | 2GB | | containers | Container:sbserver_00 | | | Mountids: \"new\" , \"data\" , \"docker\" | | | | | | | +-------------+--------------------------------+ The show output for the Hyper Protect Virtual Server was shown when it was deployed but we can bring it back up with hpvs vs show --name \"sbserver_ ${ HPVS_NUMBER } \" Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 sbserver_00 \u2502 \u2502 Status \u2502 Up About a minute \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.5 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:05 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30000 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 sb_user00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Your secure build server is now up and running! It is available at the IP Address of the Hyper Protect Virtual Server LPAR and port (GuestPort) specified. You will use this secure build server to securely build your application in the next section. Note You can assign IP addresses and hostnames for containers as necessary for your purposes but using the docker network and host ports is a nice way to quickly get running without having to use up IP addresses on your network.","title":"Create your Secure Build server"},{"location":"securebuild-lab/create-server/#create-secure-build-hyper-protect-virtual-server","text":"","title":"Create Secure Build Hyper Protect Virtual Server"},{"location":"securebuild-lab/create-server/#export-variables-set-in-previous-sections-to-current-terminal-session","text":"Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\"","title":"Export Variables set in previous sections to current terminal session"},{"location":"securebuild-lab/create-server/#create-certificate-and-key-for-mutual-tls","text":"Generate rand file openssl rand -out \" ${ HOME } /.rnd\" -hex 256 Make SB_DIR/sbs_keys directory to store secure build server keys. mkdir -p \" ${ SB_DIR } /sbs_keys\" Generate cert and key to use mutual tls openssl req -newkey rsa:2048 \\ -new -nodes -x509 \\ -days 3650 \\ -out \" ${ SB_DIR } /sbs_keys/sbs.cert\" \\ -keyout \" ${ SB_DIR } /sbs_keys/sbs.key\" \\ -subj \"/C=US/O=IBM/CN=hpvs.example.com\" Example Output Generating a RSA private key ................................+++++ ...............................+++++ writing new private key to '/home/multiarch-lab/securebuild-lab/sbs_keys/sbs.key' ----- Change cert to base64 encoding and save to new file. echo $( cat \" ${ SB_DIR } /sbs_keys/sbs.cert\" | base64 ) \\ | tr -d ' ' >> \" ${ SB_DIR } /sbs_keys/sbs_base64.cert\" Save the cert as an environment variable export cert = $( cat \" ${ SB_DIR } /sbs_keys/sbs_base64.cert\" )","title":"Create Certificate and Key for mutual tls"},{"location":"securebuild-lab/create-server/#set-your-provided-number-and-save-it-for-later-use","text":"You will be assigned a number for the lab so as not to interfere with other users. Note This table tells you which number you are assigned. Set the HPVS_NUMBER variable with your assigned 2 digit number Command Syntax export HPVS_NUMBER = \"your_assigned_number\" Example Command export HPVS_NUMBER = \"00\" Warning Your user will NOT be 00 . Please set the appropriate user you have been assigned. Save your number to bashrc for later use. echo \"export HPVS_NUMBER=' ${ HPVS_NUMBER } '\" >> \" ${ HOME } /.bashrc\" 3. Set Secure Build Server Port export SB_PORT = 300 ${ HPVS_NUMBER } Save SB_PORT to bashrc for later use. echo \"export SB_PORT=' ${ SB_PORT } '\" >> \" ${ HOME } /.bashrc\"","title":"Set your provided number and save it for later use"},{"location":"securebuild-lab/create-server/#create-quotagroup-with-storage-for-secure-build-server","text":"hpvs quotagroup create --name \"sb_user ${ HPVS_NUMBER } \" --size = 30GB Example Ouput +-------------+--------------+ | name | sb_user00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 30GB | | available | 30GB | | containers | [] | +-------------+--------------+","title":"Create Quotagroup with storage for secure build server"},{"location":"securebuild-lab/create-server/#create-securebuild-server","text":"hpvs vs create --name sbserver_ ${ HPVS_NUMBER } --repo SecureDockerBuild \\ --tag 1 .2.1-release-9b63b43 --cpu 2 --ram 2048 \\ --quotagroup \"{quotagroup = sb_user ${ HPVS_NUMBER } , mountid = new, mount = /newroot, filesystem = ext4, size = 10GB}\" \\ --quotagroup \"{quotagroup = sb_user ${ HPVS_NUMBER } , mountid = data, mount = /data, filesystem = ext4, size = 2GB}\" \\ --quotagroup \"{quotagroup = sb_user ${ HPVS_NUMBER } , mountid = docker, mount = /docker, filesystem = ext4, size = 16GB}\" \\ --env ={ EX_VOLUMES = \"/docker,/data\" ,ROOTFS_LOCK = y,CLIENT_CRT = $cert } \\ --ports \"{containerport = 443, protocol = tcp, hostport = ${ SB_PORT } }\" Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 sbserver_00 \u2502 \u2502 Status \u2502 Up Less than a second \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.5 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:05 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30000 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 sb_user00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f We can see the quotagroup is now being used with hpvs quotagroup show --name \"sb_user ${ HPVS_NUMBER } \" Example Output +-------------+--------------------------------+ | PROPERTIES | VALUES | +-------------+--------------------------------+ | name | sb_user00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 30GB | | available | 2GB | | containers | Container:sbserver_00 | | | Mountids: \"new\" , \"data\" , \"docker\" | | | | | | | +-------------+--------------------------------+ The show output for the Hyper Protect Virtual Server was shown when it was deployed but we can bring it back up with hpvs vs show --name \"sbserver_ ${ HPVS_NUMBER } \" Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 sbserver_00 \u2502 \u2502 Status \u2502 Up About a minute \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.5 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:05 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30000 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 sb_user00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Your secure build server is now up and running! It is available at the IP Address of the Hyper Protect Virtual Server LPAR and port (GuestPort) specified. You will use this secure build server to securely build your application in the next section. Note You can assign IP addresses and hostnames for containers as necessary for your purposes but using the docker network and host ports is a nice way to quickly get running without having to use up IP addresses on your network.","title":"Create Securebuild server"},{"location":"securebuild-lab/deploy-app/","text":"Deploy your Securely built application into a Hyper Protect Virtual Server \u00b6 Export Variables set in previous sections to current terminal session \u00b6 Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\" Set up you Docker Image Repository \u00b6 Register your repository hpvs repository register \\ --pgp = \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" \\ --id = \" ${ REPO_ID } \" Example Output +-----------------+------------------------------+ | repository name | docker.io/gmoney23/hpvs_bc_a | | runtime | runq | +-----------------+------------------------------+ View your newly registered repository hpvs repository show --id \" ${ REPO_ID } \" Example Output +-----------------+------------------------------+ | repository name | docker.io/gmoney23/hpvs_bc_a | | runtime | runq | +-----------------+------------------------------+ Set up your Quotagroup for storage \u00b6 Create Quotagroup hpvs quotagroup create --name = \" ${ REPO_ID } \" --size = 5GB Example Output +-------------+--------------+ | name | hpvs_bc_a_00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 5GB | | available | 5GB | | containers | [] | +-------------+--------------+ View your newly created quotagroup hpvs quotagroup show --name \" ${ REPO_ID } \" Example Output +-------------+--------------+ | name | hpvs_bc_a_00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 5GB | | available | 5GB | | containers | [] | +-------------+--------------+ Deploy your Application \u00b6 Set App port export APP_PORT = 301 ${ HPVS_NUMBER } Create your Hyper Protect Virtual Server hpvs vs create --name = ${ REPO_ID } --repo ${ REPO_ID } \\ --tag latest --cpu 2 --ram 2048 \\ --quotagroup \"{quotagroup = ${ REPO_ID } , mountid = new, mount = /newroot, filesystem = btrfs, size = 4GB}\" \\ --ports \"{containerport = 443, protocol = tcp, hostport = ${ APP_PORT } }\" Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 hpvs_bc_a_00 \u2502 \u2502 Status \u2502 Up Less than a second \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.8 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:08 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30100 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 hpvs_bc_a_00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Check on the Quotagroup (and see the application is indeed using it) hpvs quotagroup show --name \" ${ REPO_ID } \" Example Output +-------------+------------------------+ | PROPERTIES | VALUES | +-------------+------------------------+ | name | hpvs_bc_a_00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 5GB | | available | 751MB | | containers | Container:hpvs_bc_a_00 | | | Mountids:\"new\" | | | | | | | +-------------+------------------------+ We can see the Hyper Protect Virtual Server for our application is now taking up the majority of our Quotagroup. If you ever need to check the Hyper Protect Virtual Server you can use the show command hpvs vs show --name = ${ REPO_ID } Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 hpvs_bc_a_00 \u2502 \u2502 Status \u2502 Up 6 minutes \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.8 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:08 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30100 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 hpvs_bc_a_00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Access your application \u00b6 Run the following command to print the address for your electrum wallet application: echo \"https:// ${ SB_IP } : ${ APP_PORT } /electrum\" Example Output https://192.168.22.120:30100/electrum Your app is now up and running at the address printed in your terminal! Tip You can visit the IP address easily by right-clicking on the link (wih the line under it) in your terminal and selecting Open Link Info This application uses self-signed certificates so don't worry about the certificate warning you'll need to accept in your browser. Just click Advanced and then Accept the Risk and Continue In the final part of this lab you will use your newly built application...","title":"Deploy your Application in HPVS"},{"location":"securebuild-lab/deploy-app/#deploy-your-securely-built-application-into-a-hyper-protect-virtual-server","text":"","title":"Deploy your Securely built application into a Hyper Protect Virtual Server"},{"location":"securebuild-lab/deploy-app/#export-variables-set-in-previous-sections-to-current-terminal-session","text":"Source bashrc to set necessary variables if unset source \" ${ HOME } /.bashrc\"","title":"Export Variables set in previous sections to current terminal session"},{"location":"securebuild-lab/deploy-app/#set-up-you-docker-image-repository","text":"Register your repository hpvs repository register \\ --pgp = \" ${ SB_DIR } /yaml. ${ REPO_ID } .enc\" \\ --id = \" ${ REPO_ID } \" Example Output +-----------------+------------------------------+ | repository name | docker.io/gmoney23/hpvs_bc_a | | runtime | runq | +-----------------+------------------------------+ View your newly registered repository hpvs repository show --id \" ${ REPO_ID } \" Example Output +-----------------+------------------------------+ | repository name | docker.io/gmoney23/hpvs_bc_a | | runtime | runq | +-----------------+------------------------------+","title":"Set up you Docker Image Repository"},{"location":"securebuild-lab/deploy-app/#set-up-your-quotagroup-for-storage","text":"Create Quotagroup hpvs quotagroup create --name = \" ${ REPO_ID } \" --size = 5GB Example Output +-------------+--------------+ | name | hpvs_bc_a_00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 5GB | | available | 5GB | | containers | [] | +-------------+--------------+ View your newly created quotagroup hpvs quotagroup show --name \" ${ REPO_ID } \" Example Output +-------------+--------------+ | name | hpvs_bc_a_00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 5GB | | available | 5GB | | containers | [] | +-------------+--------------+","title":"Set up your Quotagroup for storage"},{"location":"securebuild-lab/deploy-app/#deploy-your-application","text":"Set App port export APP_PORT = 301 ${ HPVS_NUMBER } Create your Hyper Protect Virtual Server hpvs vs create --name = ${ REPO_ID } --repo ${ REPO_ID } \\ --tag latest --cpu 2 --ram 2048 \\ --quotagroup \"{quotagroup = ${ REPO_ID } , mountid = new, mount = /newroot, filesystem = btrfs, size = 4GB}\" \\ --ports \"{containerport = 443, protocol = tcp, hostport = ${ APP_PORT } }\" Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 hpvs_bc_a_00 \u2502 \u2502 Status \u2502 Up Less than a second \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.8 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:08 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30100 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 hpvs_bc_a_00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Check on the Quotagroup (and see the application is indeed using it) hpvs quotagroup show --name \" ${ REPO_ID } \" Example Output +-------------+------------------------+ | PROPERTIES | VALUES | +-------------+------------------------+ | name | hpvs_bc_a_00 | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 5GB | | available | 751MB | | containers | Container:hpvs_bc_a_00 | | | Mountids:\"new\" | | | | | | | +-------------+------------------------+ We can see the Hyper Protect Virtual Server for our application is now taking up the majority of our Quotagroup. If you ever need to check the Hyper Protect Virtual Server you can use the show command hpvs vs show --name = ${ REPO_ID } Example Output \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 PROPERTIES \u2502 VALUES \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Name \u2502 hpvs_bc_a_00 \u2502 \u2502 Status \u2502 Up 6 minutes \u2502 \u2502 CPU \u2502 2 \u2502 \u2502 Memory \u2502 2048 \u2502 \u2502 Networks \u2502 Network:bridge \u2502 \u2502 \u2502 IPAddress:172.31.0.8 \u2502 \u2502 \u2502 Gateway:172.31.0.1 \u2502 \u2502 \u2502 Subnet:16 \u2502 \u2502 \u2502 MacAddress:02:42:ac:1f:00:08 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Ports \u2502 LocalPort:443/tcp \u2502 \u2502 \u2502 GuestPort:30100 \u2502 \u2502 \u2502 \u2502 \u2502 Quotagroups \u2502 appliance_data \u2502 \u2502 \u2502 hpvs_bc_a_00 \u2502 \u2502 \u2502 \u2502 \u2502 State \u2502 running \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Deploy your Application"},{"location":"securebuild-lab/deploy-app/#access-your-application","text":"Run the following command to print the address for your electrum wallet application: echo \"https:// ${ SB_IP } : ${ APP_PORT } /electrum\" Example Output https://192.168.22.120:30100/electrum Your app is now up and running at the address printed in your terminal! Tip You can visit the IP address easily by right-clicking on the link (wih the line under it) in your terminal and selecting Open Link Info This application uses self-signed certificates so don't worry about the certificate warning you'll need to accept in your browser. Just click Advanced and then Accept the Risk and Continue In the final part of this lab you will use your newly built application...","title":"Access your application"},{"location":"securebuild-lab/overview/","text":"","title":"Process Overview"},{"location":"securebuild-lab/securebuild-setup/","text":"Secure Build Setup \u00b6 Add Docker registry to use for secure build \u00b6 See your current docker registries with: hpvs registry list Example Output +---------------+ | REGISTRY NAME | +---------------+ +---------------+ Set your Docker username to the username for your account on Docker Hub Command Syntax export DOCKER_USERNAME = \"my_username\" Example Command export DOCKER_USERNAME = \"gmoney23\" Note This will be the username you used when you created your Docker Hub account in the Prerequisites Save your DOCKER_USERNAME to bashrc for later use. echo \"export DOCKER_USERNAME=' ${ DOCKER_USERNAME } '\" >> \" ${ HOME } /.bashrc\" Set your Docker registry placeholder name Command Syntax export REGISTRY_NAME = \"my_registry\" Example Command export REGISTRY_NAME = \"g_docker_hub\" Save your REGISTRY_NAME to bashrc for future shells (in case you open new terminals) echo \"export REGISTRY_NAME=' ${ REGISTRY_NAME } '\" >> \" ${ HOME } /.bashrc\" Add your Docker registry with: hpvs registry add --name \" ${ REGISTRY_NAME } \" --dct https://notary.docker.io \\ --url docker.io --user \" ${ DOCKER_USERNAME } \" Note It will prompt you to enter your password. Use the Docker Hub token you have created for the lab in the Prerequisites Example Output Enter Password: List your registered Docker registries again to confirm your registry has been added. hpvs registry list Example Output +---------------+ | REGISTRY NAME | +---------------+ | g_docker_hub | +---------------+ Check the details of your added registry with hpvs registry show --name \" ${ REGISTRY_NAME } \" Example Output +------+--------------------------+ | name | g_docker_hub | | user | gmoney23 | | dct | https://notary.docker.io | | url | docker.io | +------+--------------------------+ Create directory for secure build lab and change directory \u00b6 Set your secure build directory export SB_DIR = \" $HOME /securebuild-lab\" Save SB_DIR to $HOME/.bashrc for future shells (in case you open new terminals) echo \"export SB_DIR=' ${ SB_DIR } '\" >> \" ${ HOME } /.bashrc\" Create SB_DIR and change into it mkdir -p \" ${ SB_DIR } \" && cd \" ${ SB_DIR } \" Create SSH Key and Grant GitHub access \u00b6 Create GitHub keys directory mkdir -p \" ${ SB_DIR } /github_keys\" Set GITHUB_SSH_KEY variable export GITHUB_SSH_KEY = \" ${ SB_DIR } /github_keys/github_rsa\" Save GITHUB_SSH_KEY variable in bashrc for later use echo \"export GITHUB_SSH_KEY=' ${ GITHUB_SSH_KEY } '\" >> \" ${ HOME } /.bashrc\" Create Public and private key for GitHub access ssh-keygen -t rsa -b 4096 -f \" ${ GITHUB_SSH_KEY } \" -N '' Example Output Generating public/private rsa key pair. Your identification has been saved in /home/multiarch-lab/securebuild-lab/github_keys/github_rsa. Your public key has been saved in /home/multiarch-lab/securebuild-lab/github_keys/github_rsa.pub. The key fingerprint is: SHA256:sbEfCzwyOz/LaZ4jSeKT+Aw7IWUr7YT6m8Hxv9Dq90k multiarch-lab@ubuntu The key ' s randomart image is: +--- [ RSA 4096 ] ----+ | | | | | o | | o . = | | = .. o S . | | +. = o...+ + o | | . = ++o++.E o | | . +*+++ = ++ | | . === oo*X+ | +---- [ SHA256 ] -----+ Cat GitHub public key to terminal cat \" ${ GITHUB_SSH_KEY } .pub\" Example Output ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC6zsnjH4fXaR/imYkzRaYVgWsNVIY4LzCftygKGTFJVBDMqVErsbkvF810RUTPIIowwe7Bx2UGLtwv3kL2omUJaHjol/+nzQjdmFrV2qnZosMUCn4xSpdffCmMyFWE8FnWw1ZSc7STcTD/NFzLjrN/vbJgMvla0aSxsENio2RvyFQkMKbwfojE22Q/MOtJAg0wyr9/0JNXiAyLYUEwfi1qVoF4F1mvXgLtNgTSx4VzokUKBsiSaDDbEa70ik154dtWLY9nemUsrSfUluCrHLaJhUy9cg6Jc+/9tco0cZhyZDnLIhT/4+n1XGfZxb83c5WElrg/IEYHGOHfqp+lMfusMj/0ppopz+f66dWDabVQCbrkqa+yfbw0ItC0+sZ7opIYGRLt+OelkrIECo7utzCTxdCCJ+2iUIiBV14my7xAFR+fNLKzl9KD+FTT/QoUPlqTmUQNo6NFNGG15znWVRtMDOdDiA6fugl6RrFJHDpaw9/lh+7g7tqwHGF83ZomvvFdKFMsXY6JTpj6rb7gtKzEapB9imCr0aw0ZTWTdlzTs9ksSNr1gZRf/eiztP5puC4weGDRXVjPwHOFOGbUH7Wk8ywQAmUJdEg03bz01U1htYryiNTD4VD2QfVTmxTltocj/2yv7Apv6gQ+Gb0LsgTp2aWbAnbeWX7qfjpYt0j/iw == multiarch-lab@ubuntu Copy your output to the clipboard with ctrl+shift+c . Add this key to your public GitHub (paste copied content into GitHub keys textbox) Follow these instructions for adding this public key to your github.com GitHub account. Note You created this public github.com GitHub in the Prerequisites (or already had one). Warning The above copy command ( ctrl+shift+c ) is saving the .pub public key NOT the private key. You keep the private key and GitHub uses the public key to verify that it is communicating with the owner of the private key (i.e. you). Feel at ease knowing you will delete this key from your Github account in the cleanup phase of this lab so access will be revoked soon enough","title":"Configuring your Environment"},{"location":"securebuild-lab/securebuild-setup/#secure-build-setup","text":"","title":"Secure Build Setup"},{"location":"securebuild-lab/securebuild-setup/#add-docker-registry-to-use-for-secure-build","text":"See your current docker registries with: hpvs registry list Example Output +---------------+ | REGISTRY NAME | +---------------+ +---------------+ Set your Docker username to the username for your account on Docker Hub Command Syntax export DOCKER_USERNAME = \"my_username\" Example Command export DOCKER_USERNAME = \"gmoney23\" Note This will be the username you used when you created your Docker Hub account in the Prerequisites Save your DOCKER_USERNAME to bashrc for later use. echo \"export DOCKER_USERNAME=' ${ DOCKER_USERNAME } '\" >> \" ${ HOME } /.bashrc\" Set your Docker registry placeholder name Command Syntax export REGISTRY_NAME = \"my_registry\" Example Command export REGISTRY_NAME = \"g_docker_hub\" Save your REGISTRY_NAME to bashrc for future shells (in case you open new terminals) echo \"export REGISTRY_NAME=' ${ REGISTRY_NAME } '\" >> \" ${ HOME } /.bashrc\" Add your Docker registry with: hpvs registry add --name \" ${ REGISTRY_NAME } \" --dct https://notary.docker.io \\ --url docker.io --user \" ${ DOCKER_USERNAME } \" Note It will prompt you to enter your password. Use the Docker Hub token you have created for the lab in the Prerequisites Example Output Enter Password: List your registered Docker registries again to confirm your registry has been added. hpvs registry list Example Output +---------------+ | REGISTRY NAME | +---------------+ | g_docker_hub | +---------------+ Check the details of your added registry with hpvs registry show --name \" ${ REGISTRY_NAME } \" Example Output +------+--------------------------+ | name | g_docker_hub | | user | gmoney23 | | dct | https://notary.docker.io | | url | docker.io | +------+--------------------------+","title":"Add Docker registry to use for secure build"},{"location":"securebuild-lab/securebuild-setup/#create-directory-for-secure-build-lab-and-change-directory","text":"Set your secure build directory export SB_DIR = \" $HOME /securebuild-lab\" Save SB_DIR to $HOME/.bashrc for future shells (in case you open new terminals) echo \"export SB_DIR=' ${ SB_DIR } '\" >> \" ${ HOME } /.bashrc\" Create SB_DIR and change into it mkdir -p \" ${ SB_DIR } \" && cd \" ${ SB_DIR } \"","title":"Create directory for secure build lab and change directory"},{"location":"securebuild-lab/securebuild-setup/#create-ssh-key-and-grant-github-access","text":"Create GitHub keys directory mkdir -p \" ${ SB_DIR } /github_keys\" Set GITHUB_SSH_KEY variable export GITHUB_SSH_KEY = \" ${ SB_DIR } /github_keys/github_rsa\" Save GITHUB_SSH_KEY variable in bashrc for later use echo \"export GITHUB_SSH_KEY=' ${ GITHUB_SSH_KEY } '\" >> \" ${ HOME } /.bashrc\" Create Public and private key for GitHub access ssh-keygen -t rsa -b 4096 -f \" ${ GITHUB_SSH_KEY } \" -N '' Example Output Generating public/private rsa key pair. Your identification has been saved in /home/multiarch-lab/securebuild-lab/github_keys/github_rsa. Your public key has been saved in /home/multiarch-lab/securebuild-lab/github_keys/github_rsa.pub. The key fingerprint is: SHA256:sbEfCzwyOz/LaZ4jSeKT+Aw7IWUr7YT6m8Hxv9Dq90k multiarch-lab@ubuntu The key ' s randomart image is: +--- [ RSA 4096 ] ----+ | | | | | o | | o . = | | = .. o S . | | +. = o...+ + o | | . = ++o++.E o | | . +*+++ = ++ | | . === oo*X+ | +---- [ SHA256 ] -----+ Cat GitHub public key to terminal cat \" ${ GITHUB_SSH_KEY } .pub\" Example Output ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC6zsnjH4fXaR/imYkzRaYVgWsNVIY4LzCftygKGTFJVBDMqVErsbkvF810RUTPIIowwe7Bx2UGLtwv3kL2omUJaHjol/+nzQjdmFrV2qnZosMUCn4xSpdffCmMyFWE8FnWw1ZSc7STcTD/NFzLjrN/vbJgMvla0aSxsENio2RvyFQkMKbwfojE22Q/MOtJAg0wyr9/0JNXiAyLYUEwfi1qVoF4F1mvXgLtNgTSx4VzokUKBsiSaDDbEa70ik154dtWLY9nemUsrSfUluCrHLaJhUy9cg6Jc+/9tco0cZhyZDnLIhT/4+n1XGfZxb83c5WElrg/IEYHGOHfqp+lMfusMj/0ppopz+f66dWDabVQCbrkqa+yfbw0ItC0+sZ7opIYGRLt+OelkrIECo7utzCTxdCCJ+2iUIiBV14my7xAFR+fNLKzl9KD+FTT/QoUPlqTmUQNo6NFNGG15znWVRtMDOdDiA6fugl6RrFJHDpaw9/lh+7g7tqwHGF83ZomvvFdKFMsXY6JTpj6rb7gtKzEapB9imCr0aw0ZTWTdlzTs9ksSNr1gZRf/eiztP5puC4weGDRXVjPwHOFOGbUH7Wk8ywQAmUJdEg03bz01U1htYryiNTD4VD2QfVTmxTltocj/2yv7Apv6gQ+Gb0LsgTp2aWbAnbeWX7qfjpYt0j/iw == multiarch-lab@ubuntu Copy your output to the clipboard with ctrl+shift+c . Add this key to your public GitHub (paste copied content into GitHub keys textbox) Follow these instructions for adding this public key to your github.com GitHub account. Note You created this public github.com GitHub in the Prerequisites (or already had one). Warning The above copy command ( ctrl+shift+c ) is saving the .pub public key NOT the private key. You keep the private key and GitHub uses the public key to verify that it is communicating with the owner of the private key (i.e. you). Feel at ease knowing you will delete this key from your Github account in the cleanup phase of this lab so access will be revoked soon enough","title":"Create SSH Key and Grant GitHub access"}]}